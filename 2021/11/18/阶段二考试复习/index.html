<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/changmushu.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/changmushu.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/changmushu.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/changmushu.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/changmushu.github.io/css/main.css">


<link rel="stylesheet" href="/changmushu.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"changmushu.github.io","root":"/changmushu.github.io/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Sidebar Display (only for Muse | Mist), available values":"Mist - post    expand on posts automatically. Default.","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="​         阶段二考试复习函数库  #include &lt;stack&gt; stack&lt;int&gt; q;    &#x2F;&#x2F;stack&lt;类型&gt; 名称 q.empty();   empty(); 堆栈为空，则返回true。 pop(); 移除栈顶元素。 push(); 在栈顶增加元素。 size(); 返回栈中元素数目。 top(); 返回栈顶元素。  #include">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构阶段二复习">
<meta property="og:url" content="https://changmushu.github.io/2021/11/18/%E9%98%B6%E6%AE%B5%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Chang&#39;s Blog">
<meta property="og:description" content="​         阶段二考试复习函数库  #include &lt;stack&gt; stack&lt;int&gt; q;    &#x2F;&#x2F;stack&lt;类型&gt; 名称 q.empty();   empty(); 堆栈为空，则返回true。 pop(); 移除栈顶元素。 push(); 在栈顶增加元素。 size(); 返回栈中元素数目。 top(); 返回栈顶元素。  #include">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-18T13:58:19.410Z">
<meta property="article:modified_time" content="2021-11-18T14:13:17.668Z">
<meta property="article:author" content="Mushu Chang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://changmushu.github.io/2021/11/18/%E9%98%B6%E6%AE%B5%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构阶段二复习 | Chang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/changmushu.github.io/atom.xml" title="Chang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/changmushu.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/changmushu.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/changmushu.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/changmushu.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/changmushu.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/changmushu.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/changmushu.github.io/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/changmushu.github.io/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://changmushu.github.io/2021/11/18/%E9%98%B6%E6%AE%B5%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/changmushu.github.io/images/avatar.gif">
      <meta itemprop="name" content="Mushu Chang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构阶段二复习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-18 21:58:19 / 修改时间：22:13:17" itemprop="dateCreated datePublished" datetime="2021-11-18T21:58:19+08:00">2021-11-18</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>​        </p>
<h1 id="阶段二考试复习"><a href="#阶段二考试复习" class="headerlink" title="阶段二考试复习"></a>阶段二考试复习</h1><p>函数库 </p>
<pre><code class="c++">#include &lt;stack&gt;
stack&lt;int&gt; q;    //stack&lt;类型&gt; 名称
q.empty();
</code></pre>
<ol>
<li>empty(); 堆栈为空，则返回true。</li>
<li>pop(); 移除栈顶元素。</li>
<li>push(); 在栈顶增加元素。</li>
<li>size(); 返回栈中元素数目。</li>
<li>top(); 返回栈顶元素。</li>
</ol>
<pre><code class="c++">#include &lt;queue&gt;
queue&lt;int&gt; q;    //queue&lt;类型&gt; 名称
q.push;
</code></pre>
<ol>
<li>empty(); 如果队列空则返回真。</li>
<li>push(这个里面加入你需要加入的元素或者结构体); 在末尾加入一个元素。</li>
<li>front(); 返回第一个元素。</li>
<li>back();返回最后一个元素。</li>
<li>pop(); 删除第一个元素。</li>
<li>size(); 返回队列中元素的个数。</li>
</ol>
<pre><code class="c++">#include &lt;string&gt;
strcpy(a,b);
</code></pre>
<p>将b值复制给a。</p>
<h2 id="数组、串与广义表"><a href="#数组、串与广义表" class="headerlink" title="数组、串与广义表"></a>数组、串与广义表</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="4198"><a href="#4198" class="headerlink" title="4198"></a>4198</h4><p>![屏幕截图 2021-11-17 184023](屏幕截图 2021-11-17 184023.jpg)</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void LatinMatrix(int **a,int n)
{
    // write your code here
    int i,j,p;
    for (i=0;i&lt;n;i++) {
        p = i + 1;
        for (j=0;j&lt;n;j++)
        {
            a[i][j] = (p-1)%n+1;
            p++;
        }
    }
}

void PrintMatrix(int **a,int n)
{
    int i,j;
    for (i=0;i&lt;n;i++) {
        for (j=0;j&lt;n;j++)
            printf("%d ", a[i][j]);
        printf("\n");
    }
}

int main()
{
    int n,i;
    scanf("%d", &amp;n);
    int **array = (long **)malloc(n*sizeof(long));
    for (i=0;i&lt;n;i++)
        array[i] = (long *)malloc(n*sizeof(long));
    LatinMatrix(array,n);
    PrintMatrix(array,n);
    return 0;
}
</code></pre>
<h4 id="4197"><a href="#4197" class="headerlink" title="4197"></a>4197</h4><p>![屏幕截图 2021-11-17 184609](屏幕截图 2021-11-17 184609.jpg)</p>
<pre><code class="c">#include&lt;stdio.h&gt;
int main()
{
    int n,a[100][100],r,c,i,j;
    scanf("%d",&amp;n);
    for(i=0;i&lt;n;i++)
    {
        for(j=0;j&lt;n;j++)
          scanf("%d",&amp;a[i][j]);
    }
    int sum[100]={0};
    for(i=0;i&lt;n;i++)
    {
        for(j=0;j&lt;n;j++)
          sum[i]+=a[i][j];
    }
    for(i=0;i&lt;n;i++)
    {
        int min;
        min=i;
        for(j=i+1;j&lt;=n-1;j++)
        {
            if(sum[j]&lt;sum[min])
              min=j;
        }//返回sum中最小元素的下标
        if(i!=min)
        {
            //对原数组进行转换
            for(c=0;c&lt;n;c++)
            {
                int temp1;
                temp1=a[min][c];
                a[min][c]=a[i][c];
                a[i][c]=temp1;
             }
             //对sum进行转换
             int temp;
             temp=sum[i];
             sum[i]=sum[min];
             sum[min]=temp;
        }
    }
    for(i=0;i&lt;n;i++)
    {
        for(j=0;j&lt;n;j++)
          printf("%d ",a[i][j]);
        printf("\n");
    }
    return 0;
}
</code></pre>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="4944"><a href="#4944" class="headerlink" title="4944"></a>4944</h4><p>![屏幕截图 2021-11-17 195311](屏幕截图 2021-11-17 195311.jpg)</p>
<p>这题主要用BF算法</p>
<pre><code class="c++">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define Maxsize 10
typedef struct//定义串
{
    char ch[Maxsize+1];
    int length;
}SString;

int BF(SString,SString,int);//定义

int main()
{
    SString S,T;int k=0;int a;
    scanf("%s",S.ch);
    scanf("%s",T.ch);
    S.length=strlen(S.ch);//strlen()计数长度
    T.length=strlen(T.ch);
    scanf("%d",&amp;a);
    k=BF(S,T,a);
}
int BF(SString S,SString T,int pos)
{
    int i,j;
    i=pos;
    j=0;
    while(i&lt;S.length&amp;&amp;j&lt;T.length)
    {
        if(S.ch[i]==T.ch[j])
        {
            i++;j++;
        }
        else
        {
            i=i-j+1;j=0;
        }
    }
    if(j&gt;T.length-1)
        printf("%d",i-T.length);
    else
        printf("%d",-1);
}
</code></pre>
<h4 id="4943"><a href="#4943" class="headerlink" title="4943"></a>4943</h4><p>![屏幕截图 2021-11-17 204725](屏幕截图 2021-11-17 204725.jpg)</p>
<pre><code class="c++">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define Maxsize 10
typedef struct//定义串
{
    char ch[Maxsize+1];
    int length;
}SString;
int BF(SString,SString,SString,int);
int main()
{
    SString S,T,A;int k=0;
    scanf("%s",S.ch);
    scanf("%s",T.ch);
    scanf("%s",A.ch);
    S.length=strlen(S.ch);
    T.length=strlen(T.ch);
    A.length=strlen(A.ch);
    k=BF(S,T,A,0);
}
int BF(SString S,SString T,SString A,int pos)
{
    int i,j,b,c=0;
    i=pos;
    j=0;
    while(i&lt;S.length&amp;&amp;j&lt;T.length)
    {
        if(S.ch[i]==T.ch[j])
        {
            i++;j++;
        }
        else
        {
            i=i-j+1;j=0;
        }
    }
    if(j&gt;T.length-1)
    {   for(b=i-T.length;b&lt;=A.length;b++)
        {
            S.ch[b]=A.ch[c];
            c++;
        }
         for(int a = 0;a&lt;S.length;a++)
         {
        printf("%c",S.ch[a]);
         }
    }
    else
    {
        for(int a = 0;a&lt;S.length;a++)
        {
        printf("%c",S.ch[a]);
        }
    }
}
</code></pre>
<h4 id="4203"><a href="#4203" class="headerlink" title="4203"></a>4203</h4><p>![屏幕截图 2021-11-17 205716](屏幕截图 2021-11-17 205716.jpg)</p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

#define TRUE 1
#define FALSE 0

typedef int Status;

Status isSymmetry(char *a)
{
    // write your code here
    int j;int i = 0;
    j=strlen(a)-1;
    while(i!=j&amp;&amp;i+1!=j)
    {
        if((a[i])==a[j])
        {
            i++;j--;
        }
        else{return FALSE;}
    }
    return TRUE;
}

int main()
{
    char a[20];
    gets(a);
    char *str = a;
    if (isSymmetry(str))
        printf("YES\n");
    else
        printf("NO\n");
    return 0;
}
</code></pre>
<h4 id="4941"><a href="#4941" class="headerlink" title="4941"></a>4941</h4><p>![屏幕截图 2021-11-17 210059](屏幕截图 2021-11-17 210059.jpg)</p>
<pre><code class="c">#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
using namespace std;

//write your code here
int stringToInt(char *s)
{
    int x;
    x=atoi(s);
    return x;

}

int main()
{
    char a[20],b[20];
    cin &gt;&gt; a &gt;&gt; b;
    int m = stringToInt(a);
    int n = stringToInt(b);
    cout &lt;&lt; m+n &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="4940"><a href="#4940" class="headerlink" title="4940"></a>4940</h4><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespace std;

#define defaultSize 128

class AString {
private:
    char *ch;
    int curLength;
    int maxSize;
public:
    AString(int sz=defaultSize);
    AString(const char *init);
    AString(const AString &amp;ob);
    ~AString()
    {
        if (ch!=NULL)
            delete []ch;
    }
    int Length() const { return curLength; }
    AString operator()(int pos,int len);
    int operator==(AString &amp;ob)const
    {
        return strcmp(ch,ob.ch)==0;
    }
    int operator!=(AString &amp;ob) const
    {
        return strcmp(ch,ob.ch)!=0;
    }
    int operator!() const
    {
        return curLength==0;
    }
    AString &amp;operator=(const AString &amp;ob);
    AString &amp;operator+=(const AString &amp;ob);
    char operator[](int i);
    char *getString() const
    {
        return this-&gt;ch;
    }
};

AString::AString(int sz)
{
    maxSize = sz;
    ch = new char[maxSize+1];
    curLength=0;
    ch[0]='\0';
}

AString::AString(const char *init)
{
    int len=strlen(init);
    maxSize = (len&gt;defaultSize)?len:defaultSize;
    ch = new char[maxSize+1];
    curLength = len;
    strcpy(ch,init);
}

AString::AString(const AString &amp;ob)
{
    maxSize = ob.maxSize;
    ch = new char[maxSize+1];
    curLength = ob.curLength;
    strcpy(ch,ob.ch);
}

AString AString::operator ()(int pos,int len)
{
    AString temp;
    if (pos&lt;0||pos+len-1&gt;=maxSize||len&lt;0) {
        temp.curLength = 0;
        temp.ch[0] = '\0';
    }
    else {
        if (pos+len-1&gt;=curLength)
            len = curLength-pos;
        temp.curLength = len;
        int i,j;
        for (i=0,j=pos;i&lt;len;i++,j++)
            temp.ch[i] = ch[j];
        temp.ch[len] = '\0';
    }
    return temp;
}

AString&amp; AString::operator =(const AString &amp;ob)
{
    if (&amp;ob!=this) {
        delete []ch;
        ch = new char[ob.maxSize];
        curLength = ob.curLength;
        strcpy(ch,ob.ch);
    }
    return *this;
}

AString&amp; AString::operator +=(const AString&amp; ob)
{
    char *temp = ch;
    int n = curLength+ob.curLength;
    int m = n+1;
    ch = new char[m];
    maxSize = m;
    curLength = n;
    int i;
    for (i=0;temp[i]!='\0';i++)
        ch[i] = temp[i];
    int j;
    for (j=0;ob.ch[j]!='\0';j++,i++)
        ch[i] = ob.ch[j];
    ch[i] = '\0';
    delete []temp;
    return *this;
}

char AString::operator [](int i)
{
    if (i&lt;0||i&gt;=curLength)
        return ' ';
    return ch[i];
}

int main()
{
    AString str1(20);
    str1 = "Hello World!";
    AString str2("I am a programmer.");
    AString str3(str2);
    cout &lt;&lt; str1.Length() &lt;&lt; endl;
    if (str2==str3)
        str1+=str2;
    int i;
    for (i=0;i&lt;str1.Length();i++)
        cout &lt;&lt; str1[i];
    cout &lt;&lt; endl;
    str2 = str3(7,20);
    cout &lt;&lt; str2[4] &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="计算字符出现频度"><a href="#计算字符出现频度" class="headerlink" title="计算字符出现频度"></a>计算字符出现频度</h4><pre><code class="c++">void Count()
{
    for(i=0;i&lt;36;i++) num[i]=0;
    while((ch=getchar())!='\0'）
          {
                      if('0'&lt;=ch&lt;='9')
                  {
                      i = ch-48;
                      num[i]++;
                  }
                  else if('A'&lt;=ch&lt;='Z')
                  {
                      i=ch-65+10;
                      num[i]++;
                  }
          }
    for(i=0;i&lt;10;i++)
          {
              cout&lt;&lt;"数字"&lt;&lt;i&lt;&lt;"的个数="&lt;&lt;num[i]&lt;&lt;endl;
          }
    for(i=10;i&lt;36;i++)
          {
              cout&lt;&lt;"字母字符"&lt;&lt;char(i+55)&lt;&lt;"的个数="&lt;&lt;num[i]&lt;&lt;endl;
          }
}
</code></pre>
<h4 id="字符串逆序存储"><a href="#字符串逆序存储" class="headerlink" title="字符串逆序存储"></a>字符串逆序存储</h4><pre><code class="c++">void Inverse(char A[])
{//递归实现字符串的逆序存储
    static int i = 0;        //静态变量记录字符数组的下标
    cin&gt;&gt;ch;
    if(ch!='.')            //'.'是字符串输入结束标志
    {
        Inverse(A);        //递归
        A[i++]=ch;        //递归返回后存储字符串
    }
    A[i]='\0';            //字符串最后加上结尾标记
}
</code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h4 id="4976"><a href="#4976" class="headerlink" title="4976"></a>4976</h4><p>![屏幕截图 2021-11-17 213236](屏幕截图 2021-11-17 213236.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
using namespace std;

struct TreeNode {
    int data;
    TreeNode *leftChild,*rightChild;
    TreeNode()
    {
        leftChild = NULL;
        rightChild = NULL;
    }
};

class BinaryTree {
protected:
    TreeNode *root;
    void copy(TreeNode *&amp;target,TreeNode *origin);
    void create(TreeNode *&amp;root,const int *a,int i,const int l);
    void destroy(TreeNode *&amp;root);
    TreeNode *parent(TreeNode* root,TreeNode *current);
    void exchangeLRsubTree(TreeNode *root);
public:
    BinaryTree() { root=NULL; }
    ~BinaryTree() { destroy(root); }
    void Create(BinaryTree *&amp;bt,const int *a,int i,const int l);
    TreeNode *getRoot() { return root; }
    void preOrder(TreeNode *root);
    TreeNode *Parent(TreeNode *current);
    void exchangeLRsubTree();
};

void BinaryTree::create(TreeNode *&amp;root,const int *a,int i,const int l)
{
    if (i&gt;=l)
        return;
    if (a[i]==0) {
        root = NULL;
        return;
    }
    else {
        root = new TreeNode();
        root-&gt;data = a[i];
        create(root-&gt;leftChild,a,i*2+1,l);
        create(root-&gt;rightChild,a,i*2+2,l);
    }
}

void BinaryTree::Create(BinaryTree *&amp;bt,const int *a,int i,const int l)
{
    this-&gt;create(bt-&gt;root,a,i,l);
}

TreeNode* BinaryTree::Parent(TreeNode *current)
{
    if (current==NULL||current==root)
        return NULL;
    return this-&gt;parent(this-&gt;root,current);
}

void BinaryTree::destroy(TreeNode *&amp;root)
{
    if (root-&gt;leftChild!=NULL)
        destroy(root-&gt;leftChild);
    if (root-&gt;rightChild!=NULL)
        destroy(root-&gt;rightChild);
    delete root;
    root = NULL;
}

TreeNode* BinaryTree::parent(TreeNode* root,TreeNode *current)
{
    if (root==NULL)
        return NULL;
    if (root-&gt;leftChild==current||root-&gt;rightChild==current)
        return root;
    else return (parent(root-&gt;leftChild,current)==NULL)?parent(root-&gt;rightChild,current):parent(root-&gt;leftChild,current);
}

void BinaryTree::preOrder(TreeNode *root)
{
    if (root!=NULL)
    {
        cout &lt;&lt; root-&gt;data &lt;&lt; " ";
        preOrder(root-&gt;leftChild);
        preOrder(root-&gt;rightChild);
    }
}

void BinaryTree::exchangeLRsubTree()
{
    this-&gt;exchangeLRsubTree(this-&gt;root);
}

void BinaryTree::exchangeLRsubTree(TreeNode *root)
{
    // write your code here
     // write your code here
    TreeNode *temp;
    if(root==NULL) return;
    if(root-&gt;leftChild==NULL&amp;&amp;root-&gt;rightChild==NULL)
        return;
    else
    {
        temp=root-&gt;leftChild;
        root-&gt;leftChild=root-&gt;rightChild;
        root-&gt;rightChild=temp;
    }
    exchangeLRsubTree(root-&gt;leftChild);
    exchangeLRsubTree(root-&gt;rightChild);
}

int main()
{
    int length = 10;
    cin &gt;&gt; length;
    int *a = new int[length];
    int i;
    for (i=0;i&lt;length;i++)
        cin &gt;&gt; a[i];
    BinaryTree *bt = new BinaryTree();
    bt-&gt;Create(bt,a,0,length);
    bt-&gt;exchangeLRsubTree();
    bt-&gt;preOrder(bt-&gt;getRoot());
    return 0;
}
</code></pre>
<h4 id="6111"><a href="#6111" class="headerlink" title="6111"></a>6111</h4><p>![屏幕截图 2021-11-18 103227](屏幕截图 2021-11-18 103227.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;

#define MAXSIZE 30

typedef struct BiTNode{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;;

void Creat(BiTNode *&amp;T){   //先序建立二叉树 ，存放表达式
    char ch;
    cin&gt;&gt;ch;
    if(ch == '*')T = NULL;
    else{
        T = new BiTNode;
        T-&gt;data = ch;
        Creat(T-&gt;lchild);
        Creat(T-&gt;rchild);
    }
}

bool PrintAncestors(BiTree T,int x)
{
    if(!T) return false;
    if (T-&gt;data == x) return true;

    if (PrintAncestors(T-&gt;lchild, x) || PrintAncestors(T-&gt;rchild, x))
    {
        cout &lt;&lt; T-&gt;data &lt;&lt; " ";
        return true;
    }

    return false;
}

void InOrderTraverse(BiTree T,int x,int &amp;tag)
{
    if(T)
    {
        if(T-&gt;data==x){tag=1;}
        InOrderTraverse(T-&gt;lchild,x,tag);
        InOrderTraverse(T-&gt;rchild,x,tag);
    }
}

int main(){
    char x;int tag = 0;
    BiTNode *tree;
    char expression[MAXSIZE];
    char path[MAXSIZE];
    Creat(tree);
    cin&gt;&gt;x;
    InOrderTraverse(tree,x,tag);
    if(tree-&gt;data==x)
    {
        printf("没有祖先结点");
    }else if(tag==0)
    {
        printf("%c不存在",x);
    }else
    {
        PrintAncestors(tree,x);
    }
}

</code></pre>
<h4 id="7075"><a href="#7075" class="headerlink" title="7075"></a>7075</h4><p>前中后序遍历改输出的位置即可。</p>
<p>![屏幕截图 2021-11-18 165313](屏幕截图 2021-11-18 165313.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;

#define MAXSIZE 30

typedef struct BiTNode{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;;

void Creat(BiTNode *&amp;T){   //先序建立二叉树 ，存放表达式
    char ch;
    cin&gt;&gt;ch;
    if(ch == '@')T = NULL;
    else{
        T = new BiTNode;
        T-&gt;data = ch;
        Creat(T-&gt;lchild);
        Creat(T-&gt;rchild);
    }
}

void InOrderTraverse(BiTree T)
{
    if(T)
    {
        InOrderTraverse(T-&gt;lchild);
        InOrderTraverse(T-&gt;rchild);
        cout&lt;&lt;T-&gt;data;
    }
}

int main(){
    BiTNode *tree;
    char expression[MAXSIZE];
    char path[MAXSIZE];
    Creat(tree);
    InOrderTraverse(tree);
}
</code></pre>
<h4 id="7077"><a href="#7077" class="headerlink" title="7077"></a>7077</h4><p>层次遍历</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

typedef struct BinNode{
    char data;
    struct BinNode *left;
    struct BinNode *right;
}BinNode,*BinTree;
#define MAXSIZE 1024
typedef struct{
    BinTree data[MAXSIZE];
    int front,rear;
}SeQueue;
void QueueInit(SeQueue &amp;Q){
    Q.front=0;Q.rear=0;
}
void QueuePush(SeQueue &amp;Q,BinTree x){
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%MAXSIZE;
}
void GetHead(SeQueue Q,BinTree &amp;x){
    x=Q.data[Q.front];
}
bool QueueEmpty(SeQueue Q){
    if(Q.front==Q.rear)return 1;
    return 0;
}
void QueuePop(SeQueue &amp;Q,BinTree &amp;x){
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MAXSIZE;
}

void CreateBinTree(BinTree &amp;T){
    char ch;cin&gt;&gt;ch;
    if(ch=='@')T=NULL;
    else{
        T=new BinNode;
        T-&gt;data=ch;
        CreateBinTree(T-&gt;left);
        CreateBinTree(T-&gt;right);
    }
}

void BfsTree(BinTree T){
    SeQueue Q;QueueInit(Q);
    QueuePush(Q,T);
    while(!QueueEmpty(Q)){
        BinTree output;
        output=new BinNode;
        QueuePop(Q,output);
        cout&lt;&lt;output-&gt;data;
        if(output-&gt;left!=NULL)QueuePush(Q,output-&gt;left);
        if(output-&gt;right!=NULL)QueuePush(Q,output-&gt;right);
    }
}

int main(){
    BinTree T;
    CreateBinTree(T);
    BfsTree(T);
    return 0;
}
</code></pre>
<h4 id="7076"><a href="#7076" class="headerlink" title="7076"></a>7076</h4><p>输出叶子结点个数</p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;

#define MAXSIZE 30

typedef struct BiTNode{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;;

void Creat(BiTNode *&amp;T){   //先序建立二叉树 ，存放表达式
    char ch;
    cin&gt;&gt;ch;
    if(ch == '@')T = NULL;
    else{
        T = new BiTNode;
        T-&gt;data = ch;
        Creat(T-&gt;lchild);
        Creat(T-&gt;rchild);
    }
}

int LeafCount(BiTree T)
{
    if(T==NULL) return 0;
    else
    {
        if((!T-&gt;lchild)&amp;&amp;(!T-&gt;rchild))
            return 1;
        else
            return LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);
    }
}

int main(){
    BiTNode *tree;
    char expression[MAXSIZE];
    char path[MAXSIZE];
    Creat(tree);
    cout&lt;&lt;LeafCount(tree);
}

</code></pre>
<h4 id="7074"><a href="#7074" class="headerlink" title="7074"></a>7074</h4><p>输出二叉树高度</p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;

#define MAXSIZE 30

typedef struct BiTNode{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;;

void Creat(BiTNode *&amp;T){   //先序建立二叉树 ，存放表达式 
    char ch;
    cin&gt;&gt;ch;
    if(ch == '@')T = NULL;
    else{
        T = new BiTNode;
        T-&gt;data = ch;
        Creat(T-&gt;lchild);
        Creat(T-&gt;rchild);
    }
}

int Depth(BiTree T)
{
    int m,n;
    if(T==NULL) return 0;
    else{
        m=Depth(T-&gt;lchild);
        n=Depth(T-&gt;rchild);
        if(m&gt;n) return(m+1);
        else return(n+1);
    }
}

int main(){
    BiTNode *tree;
    char expression[MAXSIZE]; 
    char path[MAXSIZE];
    Creat(tree);
    cout&lt;&lt;Depth(tree);
}
</code></pre>
<h4 id="7080"><a href="#7080" class="headerlink" title="7080"></a>7080</h4><p>![屏幕截图 2021-11-18 165848](屏幕截图 2021-11-18 165848.jpg)</p>
<pre><code class="c++">#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;iostream&gt;
using namespace std;

typedef struct BinNode{
    char data;
    struct BinNode *left;
    struct BinNode *right;
}BinNode,*BinTree;

void CreateBinTree(BinTree &amp;T){
    char ch;cin&gt;&gt;ch;
    if(ch=='@')T=NULL;
    else{
        T=new BinNode;
        T-&gt;data=ch;
        CreateBinTree(T-&gt;left);
        CreateBinTree(T-&gt;right);
    }
}


int CountLeaf(BinTree T){
    int res=0;
    if(T==NULL)return 0;
    if(T-&gt;left==NULL)return 1+CountLeaf(T-&gt;right);
    else return CountLeaf(T-&gt;left)+CountLeaf(T-&gt;right);
}
int main(){
    BinTree T;
    CreateBinTree(T);
    printf("%d",CountLeaf(T));
    return 0;
}
</code></pre>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><h4 id="7039-有向图"><a href="#7039-有向图" class="headerlink" title="7039(有向图)"></a>7039(有向图)</h4><p>![屏幕截图 2021-11-18 125414](屏幕截图 2021-11-18 125414.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;

const int MAXNum=100;

typedef struct ArcNode              //边结点
{
    int adjvex;                     //该边所指向的顶点的位置
    struct ArcNode * nextarc;       //指向下一条边的指针
}ArcNode;

typedef struct VNode                //顶点信息
{
    int data;
    ArcNode *firstarc;              //指向第一条依附该顶点的边的指针
}VNode,AdjList[MAXNum];             //AdjList表示邻接表的类型

typedef struct                      //邻接表
{
    AdjList verlist;
    int vexnum,arcnum;              //图的当前顶点数和边数
}Graph;

void CreateUDG(Graph &amp;G)
{                                   //采用邻接表表示法，创建有向图G
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        cin&gt;&gt;G.verlist[i].data;
        G.verlist[i].firstarc=NULL;
    }
    for(int i = 1;i&lt;=G.arcnum;i++)
    {
        int x,y;cin&gt;&gt;x&gt;&gt;y;

        ArcNode * p1 = new ArcNode;

        p1-&gt;adjvex = y;
        p1-&gt;nextarc = G.verlist[x].firstarc;
        G.verlist[x].firstarc=p1;

    }
}

void Print(Graph G)
{
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        ArcNode* p = G.verlist[i].firstarc;
        cout&lt;&lt;i&lt;&lt;":";
        while(p!=NULL){
            cout&lt;&lt;p-&gt;adjvex;
            if(p-&gt;nextarc!=NULL)cout&lt;&lt;" ";
            p=p-&gt;nextarc;
        }
        cout&lt;&lt;endl;
    }
}
bool vis[MAXNum];
void DFS(Graph G,int u)
{
    ArcNode* p=G.verlist[u].firstarc;
    vis[u]=true;
    cout&lt;&lt;u&lt;&lt;" ";
    while(p!=NULL)
    {
        if(!vis[p-&gt;adjvex])
        {
            DFS(G,p-&gt;adjvex);
        }
        p=p-&gt;nextarc;
    }
}

int main()
{
    Graph G;
    CreateUDG(G);
    Print(G);
    DFS(G,1);
    return 0;
}
</code></pre>
<h4 id="7040-有向图"><a href="#7040-有向图" class="headerlink" title="7040(有向图)"></a>7040(有向图)</h4><p>![屏幕截图 2021-11-18 133703](屏幕截图 2021-11-18 133703.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;

const int MAXNum=100;

typedef struct ArcNode              //边结点
{
    int adjvex;                     //该边所指向的顶点的位置
    struct ArcNode * nextarc;       //指向下一条边的指针
}ArcNode;

typedef struct VNode                //顶点信息
{
    int data;
    ArcNode *firstarc;              //指向第一条依附该顶点的边的指针
}VNode,AdjList[MAXNum];             //AdjList表示邻接表的类型

typedef struct                      //邻接表
{
    AdjList verlist;
    int vexnum,arcnum;              //图的当前顶点数和边数
}Graph;

void CreateUDG(Graph &amp;G)
{                                   //采用邻接表表示法，创建有向图G
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        cin&gt;&gt;G.verlist[i].data;
        G.verlist[i].firstarc=NULL;
    }
    for(int i = 1;i&lt;=G.arcnum;i++)
    {
        int x,y;cin&gt;&gt;x&gt;&gt;y;

        ArcNode * p1 = new ArcNode;

        p1-&gt;adjvex = y;
        p1-&gt;nextarc = G.verlist[x].firstarc;
        G.verlist[x].firstarc=p1;

    }
}
int in[MAXNum],out[MAXNum];
void TD(Graph G)
{
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        ArcNode* p = G.verlist[i].firstarc;
        while(p!=NULL)
        {
            in[p-&gt;adjvex]++;
            out[i]++;
            p=p-&gt;nextarc;
        }
    }
}

int main(){
    Graph G;
    CreateUDG(G);
    TD(G);
    for(int i=1;i&lt;=G.vexnum;i++){
        cout&lt;&lt;i&lt;&lt;":"&lt;&lt;in[i]&lt;&lt;" "&lt;&lt;out[i]&lt;&lt;" "&lt;&lt;in[i]+out[i]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h4 id="7042-无向图"><a href="#7042-无向图" class="headerlink" title="7042(无向图)"></a>7042(无向图)</h4><p>![屏幕截图 2021-11-18 151633](屏幕截图 2021-11-18 151633.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;

using namespace std;

const int MAXNum=105;

typedef struct ArcNode              //边结点
{
    int adjvex;                     //该边所指向的顶点的位置
    struct ArcNode * nextarc;       //指向下一条边的指针
}ArcNode;

typedef struct VNode                //顶点信息
{
    int data;
    ArcNode *firstarc;              //指向第一条依附该顶点的边的指针
}VNode,AdjList[MAXNum];             //AdjList表示邻接表的类型

typedef struct                      //邻接表
{
    AdjList verlist;
    int vexnum,arcnum;              //图的当前顶点数和边数
}Graph;

void CreateUDG(Graph &amp;G)
{                                   //采用邻接表表示法，创建有向图G
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        cin&gt;&gt;G.verlist[i].data;
        G.verlist[i].firstarc=NULL;
    }
    for(int i = 1;i&lt;=G.arcnum;i++)
    {
        int x,y;cin&gt;&gt;x&gt;&gt;y;

        ArcNode * p1 = new ArcNode;
        ArcNode * p2 = new ArcNode;

        p1-&gt;adjvex = y;
        p1-&gt;nextarc = G.verlist[x].firstarc;
        G.verlist[x].firstarc=p1;

        p2-&gt;adjvex = x;
        p2-&gt;nextarc = G.verlist[y].firstarc;
        G.verlist[y].firstarc=p2;
    }
}
/*递归
bool visited[MAXNum];
void DFS(Graph G,int v)
{
    cout&lt;&lt;"v"&lt;&lt;v&lt;&lt;" ";visited[v]=true;
    ArcNode * p = G.verlist[v].firstarc;
    while(p!=NULL)
    {
        if(!visited[p-&gt;adjvex]){DFS(G,p-&gt;adjvex);}
        p = p-&gt;nextarc;
    }
}*/

bool visited[MAXNum];
void DFS(Graph G,int v)        //非递归
{
    stack&lt;int&gt;q;
    q.push(v);visited[v]=true;
    cout&lt;&lt;"v1 ";
    while(!q.empty())
    {
        int t=q.top();
        ArcNode *p=G.verlist[t].firstarc;
        while(p&amp;&amp;visited[p-&gt;adjvex])
        {
            p=p-&gt;nextarc;
        }
        while(p&amp;&amp;!visited[p-&gt;adjvex])
        {
            cout&lt;&lt;"v"&lt;&lt;p-&gt;adjvex&lt;&lt;" ";
            visited[p-&gt;adjvex]=true;
            q.push(p-&gt;adjvex);
            p=G.verlist[p-&gt;adjvex].firstarc;
        }
        if(p==NULL){q.pop();}
    }
}

int main()
{
    Graph G;
    CreateUDG(G);
    DFS(G,1);
    return 0;
}
</code></pre>
<h4 id="╳7043-无向图的建立与遍历）"><a href="#╳7043-无向图的建立与遍历）" class="headerlink" title="╳7043(无向图的建立与遍历）"></a>╳7043(无向图的建立与遍历）</h4><p>![屏幕截图 2021-11-18 153324](屏幕截图 2021-11-18 153324.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;

using namespace std;

const int MAXNum=100;

typedef struct ArcNode              //边结点
{
    int adjvex;                     //该边所指向的顶点的位置
    struct ArcNode * nextarc;//指向下一条边的指针
    //OtherInfo info；            //和边相关的信息
}ArcNode;

typedef struct VNode                //顶点信息
{
    int data;
    ArcNode *firstarc;              //指向第一条依附该顶点的边的指针
}VNode,AdjList[MAXNum];             //AdjList表示邻接表的类型

typedef struct                      //邻接表
{
    AdjList verlist;
    int vexnum,arcnum;              //图的当前顶点数和边数
}Graph;

int LocateVex(Graph G,char v)
{
    for(int i = 1;i&lt;G.vexnum;i++)
    {
        if(G.verlist[i].data==v)
        {
            return i;
        }
    }
}

void CreateUDG(Graph &amp;G)
{                                   //采用邻接表表示法，创建无向图G
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;        //输入各点，构造表头结点表
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        cin&gt;&gt;G.verlist[i].data;        //输入顶点值
        G.verlist[i].firstarc=NULL;    //初始化表头结点的指针域为NULL
    }
    for(int i = 1;i&lt;=G.arcnum;i++)    //输入各边，构造邻接表
    {
        int v1,v2;cin&gt;&gt;v1&gt;&gt;v2;        //输入一条边依附的两个顶点
        int a,b;
        a = LocateVex(G,v1);b = LocateVex(G,v2);

        ArcNode * p1 = new ArcNode;
        ArcNode * p2 = new ArcNode;

        p1-&gt;adjvex = b;
        p1-&gt;nextarc = G.verlist[a].firstarc;
        G.verlist[a].firstarc=p1;

        p2-&gt;adjvex = a;
        p2-&gt;nextarc = G.verlist[b].firstarc;
        G.verlist[b].firstarc=p2;
    }
}
/*递归
bool visited[MAXNum];
void DFS(Graph G,int v)
{
    cout&lt;&lt;"v"&lt;&lt;v&lt;&lt;" ";visited[v]=true;
    ArcNode * p = G.verlist[v].firstarc;
    while(p!=NULL)
    {
        if(!visited[p-&gt;adjvex]){DFS(G,p-&gt;adjvex);}
        p = p-&gt;nextarc;
    }
}*/

/*非递归
bool visited[MAXNum];
void DFS(Graph G,int v)
{
    stack&lt;int&gt;q;
    q.push(v);visited[v]=true;
    cout&lt;&lt;"v1 ";
    while(!q.empty())
    {
        int t=q.top();
        ArcNode *p=G.verlist[t].firstarc;
        while(p&amp;&amp;visited[p-&gt;adjvex])
        {
            p=p-&gt;nextarc;
        }
        while(p&amp;&amp;!visited[p-&gt;adjvex])
        {
            cout&lt;&lt;"v"&lt;&lt;p-&gt;adjvex&lt;&lt;" ";
            visited[p-&gt;adjvex]=true;
            q.push(p-&gt;adjvex);
            p=G.verlist[p-&gt;adjvex].firstarc;
        }
        if(p==NULL){q.pop();}
    }
}*/

bool visited[MAXNum];
void BFS(Graph G)
{
    queue&lt;int&gt; q;
    cout&lt;&lt;"v1 ";
    q.push(1);
    visited[1]=true;
    while(!q.empty())
    {
        int u = q.front();q.pop();
        ArcNode* p = G.verlist[u].firstarc;
        while(p!=NULL)
        {
            if(!visited[p-&gt;adjvex])
            {
                cout&lt;&lt;"v"&lt;&lt;p-&gt;adjvex&lt;&lt;" ";
                visited[p-&gt;adjvex]=true;
                q.push(p-&gt;adjvex);
            }
            p=p-&gt;nextarc;
        }

    }
}

int main()
{
    Graph G;
    CreateUDG(G);
    BFS(G);
    return 0;
}
</code></pre>
<h4 id="6112-有向图"><a href="#6112-有向图" class="headerlink" title="6112(有向图)"></a>6112(有向图)</h4><p>![屏幕截图 2021-11-18 180909](屏幕截图 2021-11-18 180909.jpg)</p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;

const int MAXNum=100;

typedef struct ArcNode              //边结点
{
    int adjvex;                     //该边所指向的顶点的位置
    struct ArcNode * nextarc;       //指向下一条边的指针
}ArcNode;

typedef struct VNode                //顶点信息
{
    int data;
    ArcNode *firstarc;              //指向第一条依附该顶点的边的指针
}VNode,AdjList[MAXNum];             //AdjList表示邻接表的类型

typedef struct                      //邻接表
{
    AdjList verlist;
    int vexnum,arcnum;              //图的当前顶点数和边数
}Graph;

void CreateUDG(Graph &amp;G)
{                                   //采用邻接表表示法，创建有向图G
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        G.verlist[i].data=i;
        G.verlist[i].firstarc=NULL;
    }
    for(int i = 1;i&lt;=G.arcnum;i++)
    {
        char m;
        int x,y;cin&gt;&gt;x&gt;&gt;m&gt;&gt;y;

        ArcNode * p1 = new ArcNode;

        p1-&gt;adjvex = y;
        p1-&gt;nextarc = G.verlist[x].firstarc;
        G.verlist[x].firstarc=p1;
    }
}

bool vis[MAXNum];
bool DFS(Graph G,int i,int j)
{
    if(i==j)return true;
    ArcNode* p=G.verlist[i].firstarc;
    vis[i]=true;
    while(p!=NULL)
    {
        if(!vis[p-&gt;adjvex] &amp;&amp; DFS(G,p-&gt;adjvex,j))
        {
           return true;
        }
        p=p-&gt;nextarc;
    }
    return false;
}


int main()
{
    int tag1 = 1;int tag0 = 0;
    int i,j;
    Graph G;
    CreateUDG(G);
    cin&gt;&gt;i&gt;&gt;j;
    if(DFS(G,i,j))
    {
        cout&lt;&lt;1;
    }else
    {
        cout&lt;&lt;0;
    }
    return 0;
}
</code></pre>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h4 id="╳邻接矩阵的建立与遍历"><a href="#╳邻接矩阵的建立与遍历" class="headerlink" title="╳邻接矩阵的建立与遍历"></a>╳邻接矩阵的建立与遍历</h4><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;

using namespace std;

#define MaxInt 32767        //表示极大值
#define MVNum 100            //最大顶点数
typedef char VerTexType;    //假设顶点的数据类型为字符型
typedef int ArcType;        //假设边的权值类型为整数
typedef struct
{
    VerTexType vexs[MVNum];    //顶点表
    ArcType arcs[MVNum][MVNum];    //邻接矩阵
    int vexnum,arcnum;        //图的当前点数和边数
}AMGraph;


int LocateVex(AMGraph G,char v)
{
    for(int i = 1;i&lt;G.vexnum;i++)
    {
        if(G.vexs[i]==v)
        {
            return i;
        }
    }
}

void CreateUDN(AMGraph &amp;G)
{//采用邻接矩阵表示法，创建无向图
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;                    //输入总顶点数，总边数
    for(int i = 1;i&lt;=G.vexnum;i++)               //依次输入点的信息
    {
        cin&gt;&gt;G.vexs[i];
    }
    for(int i = 1;i&lt;=G.vexnum;i++)               //初始化邻接矩阵，边的权值为极大值
    {
        for(int j = 1;j&lt;=G.vexnum;j++)
        {
            G.arcs[i][j] = 0;//G.arcs[i][j] = MaxInt;
        }
    }
    for(int k = 1;k&lt;=G.arcnum;k++)               //构造邻接矩阵
    {
        char v1,v2;//int w;                       //输入一条边依附的顶点及权值
        cin&gt;&gt;v1&gt;&gt;v2;//cin&gt;&gt;w;

        int i,j;
        i = LocateVex(G,v1);j = LocateVex(G,v2);//确定v1和v2在G中的位置，即顶点数组的下标
        G.arcs[i][j] = 1;                       //边&lt;v1,v2&gt;权值为0
        G.arcs[j][i] = G.arcs[i][j];            //置&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;的权值为0，有向图删此条代码
    }
}

bool visited[MVNum];
void DFS_AM(AMGraph G,int v)
{//图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G
    cout&lt;&lt;v&lt;&lt;" ";visited[v] = true;                //访问第v个顶点，并置访问标志数组相应分量值为true
    for(int w = 1;w&lt;=G.vexnum;w++)                //依次检查邻接矩阵v所在的行
    {
        if((G.arcs[v][w]!=0)&amp;&amp;(!visited[w]))
        {
            DFS_AM(G,w);
        }
    }
}

int main()
{
    AMGraph G;
    CreateUDN(G);
    for(int i = 1;i&lt;=G.vexnum;i++)
    {
        cout&lt;&lt;"\n";
        for(int j = 1;j&lt;=G.vexnum;j++)
        {
            cout&lt;&lt;G.arcs[i][j]&lt;&lt;" ";
        }
    }
    cout&lt;&lt;"\n";
    DFS_AM(G,1);
    return 0;
}
</code></pre>
<p>​        若要建立无向网，只需对上述算法做两处小的改动：一是初始化邻接矩阵时，将边的权值改为MaxInt；二是构造邻接矩阵时，将权值w输入。</p>
<p>​        若要建立有向图，则不需要建立对称矩阵。</p>

    </div>

    
    
    

    
      <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 <i class="fa fa-heart"></i> 感谢阅读-------------</div>

    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Mushu Chang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://changmushu.github.io/2021/11/18/%E9%98%B6%E6%AE%B5%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/" title="数据结构阶段二复习">https://changmushu.github.io/2021/11/18/阶段二考试复习/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/changmushu.github.io/2021/10/03/Olympus35-S/" rel="prev" title="Olympus35-S">
      <i class="fa fa-chevron-left"></i> Olympus35-S
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">阶段二考试复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%B2%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">数组、串与广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4198"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">4198</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4197"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">4197</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">1.1.2.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4944"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">4944</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4943"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">4943</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4203"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">4203</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4941"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">4941</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4940"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">4940</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E5%BA%A6"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">计算字符出现频度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%86%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">字符串逆序存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4976"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">4976</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6111"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">6111</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7075"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">7075</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7077"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">7077</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7076"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">7076</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7074"><span class="nav-number">1.2.0.6.</span> <span class="nav-text">7074</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7080"><span class="nav-number">1.2.0.7.</span> <span class="nav-text">7080</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">1.3.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">邻接表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7039-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">7039(有向图)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7040-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">7040(有向图)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7042-%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">7042(无向图)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%95%B37043-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86%EF%BC%89"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">╳7043(无向图的建立与遍历）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6112-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">6112(有向图)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">1.3.2.</span> <span class="nav-text">邻接矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%95%B3%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">╳邻接矩阵的建立与遍历</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mushu Chang"
      src="/changmushu.github.io/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Mushu Chang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/changmushu.github.io/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/changmushu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;changmushu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1173727758@qq.com" title="E-Mail → mailto:1173727758@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/changmushu.github.io/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Changmushu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">26k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">24 分钟</span>
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/changmushu.github.io/lib/anime.min.js"></script>
  <script src="/changmushu.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/changmushu.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/changmushu.github.io/js/utils.js"></script>

<script src="/changmushu.github.io/js/motion.js"></script>


<script src="/changmushu.github.io/js/schemes/muse.js"></script>


<script src="/changmushu.github.io/js/next-boot.js"></script>




  




  
<script src="/changmushu.github.io/js/local-search.js"></script>













  

  

<script src="/changmushu.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/changmushu.github.io/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>

<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</html>
